面向对象编程：ECMAScript 的实现
目录：
1. 介绍
2. ECMAScript 面向对象实现
	1. 数据类型
		1. 基本数据类型
		2. 对象类型
			1. 动态特性
			2. 内建对象、本地对象和宿主对象
			3. Boolean，String 和 Number 对象
			4. 字面表示法
				1. 正则表达式字面量和 RegExp 对象
			5. 关联数组？
			6. 类型转换
			7. 属性特性
			8. 内部属性和方法
	2. 构造器
		1. 对象构造的算法
	3. 原型
		1. 属性构造器
		2. 外显原型和隐藏的 `[[Prototype]]` 属性
		3. 非标准定义的` __proto__` 属性
		4. 对象独立于它的构造器
		5. `instanceof` 操作符的特性
		6. 作为存储方法共享属性的原型
	4. 读取和写入属性
		1. `[[Get]]`方法
		2. `[[Put]]`方法
		3. 属性获取符
	5. 继承
		1. 原型链
3. 结论
4. 其他文献

## 1. 介绍
这是介绍 ECMAScirpt 面向对象编程的下半部，在上半部我们讨论了面向对象编程的总体理论，介绍了 ECMAScirpt 在这些方面的做法，下半部将讨论 ECMAScirpt OOP 的实现细节，建议先阅读上半部分，再继续往下读。上半部的链接：[ECMA-262-3 in detail. Chapter 7.1. OOP: The general theory.](http://dmitrysoshnikov.com/ecmascript/chapter-7.1-oop-general-theory/)

## 2. ECMAScript 面向对象实现
在讨论细节之前，我们下一个定义：
> ECMAScirpt 是一门面向对象的编程语言，支持基于原型的委托式继承。

我们从数据类型开始分析，ECMAScirpt 把 `基本值`（primitive values）和`对象`做了区分，所以说“JavaScript 中的一切都是对象” 这话并不严谨， `基本值` 中涉及到特定的数据类型，我们之后会讨论到。

### 1. 数据类型
尽管 ECMAScirpt 是一门动态、具有鸭子类型风格和自动类型转换的弱类型语言，它还是有特定的数据类型，这意味着，在某个时刻，对象属于某个具体的类型。

标准定义了九种类型，其中六种在 ECMAScirpt 程序中可以直接访问：
- Undefined
- Null
- Boolean
- String
- Number
- Object

其他三种类型只在实现层面（implementation level）可以访问，用于解释一些操作符的行为、存储中间值等，这三种类型如下：
- Reference
- List
- Completion

`Reference` 类型用于解释`delete`, `typeof`, `this`等操作符，由一个基本对象和属性名构成；`List` 类型描述（在`new` 表达式和函数调用中）参数列表的行为；`Completion` 类型用于解释`break`, `continue`，`return` 和 `throw` 语句的行为。

#### 1.1 基本数据类型
回到 ECMAScript 程序的六种数据类型，前五种 `Undefined`,`Null`,`Boolean`,`String`,`Number`,是基本值（primitive values，或称原始值），这些基本值实现在一个低级层面，它们不是对象，没有原型或构造器。

有一点特殊的表现是，当把 `typeof` 操作符放在 `null` 值的前面，会返回 `object` ，显然这和 `null` 值属于 `Null` 类型的规定不符合。造成这种现象的原因是在标准中规定了：
> 对于 `null` 值（ `typeof` ）应该返回字符串“object”
标准没有进一步解释为什么。这里参考JS 作者 [Brendan Eich 对null 和 undefined 的区分](http://groups.google.com/group/netscape.public.mozilla.jseng/msg/4306c3b86de8c0d9)：
> 当你通过合法的表达式访问对象一个属性，但这个属性并不在对象中（既没有在这个对象里，也不在它的原型链里），会返回 undefined；null 值表示“空对象”或者“空引用”。

#### 1.2 对象类型
接着是对象类型，它是代表 ECMAScript 对象的唯一类型。
> 对象是没有无序键-值对的集合
对象中的键叫`属性`，属性是基本值和其他对象的容器，如何属性这个容器容纳的是函数，那它叫做`方法`。

##### 1.2.1 动态特性
ES 中的对象是动态的，意味着在程序执行的任何时候，我们都能对对象的属性进行增加、修改或移除。以下对增加、修改、移除属性的代码进行演示：
```javascript
var foo = {x: 10};
// 新增一个属性
foo.y = 20;
console.log(foo); // {x: 10, y: 20}
// 把属性值改成一个函数
foo.x = function () {
  console.log('foo.x');
};
 
foo.x(); // 'foo.x'
 
// 用delete 删除属性
delete foo.x;
console.log(foo); // {y: 20}
```
具有 `read-only` 特性的属性无法修改，具有`non-configurable` 特性的属性无法删除，这些特性我们在 `1.2.7 属性特性` 这节中讨论。

注：ES5 定义了`静态`对象，即不能新增属性，也不能删改已有属性，它们叫冷藏对象（frozen object），用`Object.freeze(o)`方法，可以得到一个冷藏对象。

`Object.preventExtensions(o)`方法能让 `o` 对象不能新增属性；
`Object.defineProperty(o)`方法能针对性修改`o` 对象某个属性的特性：
```javascript
var foo = {x : 10};
Object.defineProperty(foo, "y", { // 新建一个y 属性，设置只读且不能被删除
  value: 20,
  writable: false, // read-only
  configurable: false // non-configurable
});
// 无法修改
foo.y = 200;
// 无法删除
delete foo.y; // false
// 阻止foo 对象新增属性
Object.preventExtensions(foo);
console.log(Object.isExtensible(foo)); // false
// 无法新增属性
foo.z = 30;
console.log(foo); {x: 10, y: 20}
```

##### 1.2.2 内建对象、本地对象和宿主对象
ECMAScript 标准对内建对象（Built-in object）、本地对象（native objects）和宿主对象（host objects）做了区分。
内建对象和本地对象由ECMAScript 标准和其实现来定义，它们之间的区别很小。本地对象是ECMAScript 的实现提供的所有对象，有些是内建的，有些可以是程序执行过程中创建的，如用户定义的对象。
内建对象属于本地对象，是程序开始执行之前，就在ECMAScript 中构建好的对象，如`parseInt`，`Math`对象等。
宿主对象是宿主环境提供的对象，典型宿主对象如一个浏览器，提供了`window`,`console.log` 等对象。宿主对象也可以用 ES 进行实现，和标准保持一样的语法，从这个角度说，它们可以叫做“本地-宿主”对象（“native-host” objects），当然，这只是说说，标准并没有这么定义。

##### 1.2.3 Boolean，String 和 Number 对象
对于一些基本类型，标准定义了特殊的包裹对象（wrapper object），有这三种：
- Boolean-object
- String-object
- Number-object
这些对象是用相关内在构造器创建的，它们包含基本值作为内部属性之一，这些对象代表（Object representation）能转换成基本值，反过来一样。

例子：基本值对应的对象
```javascript
// 通过new 操作符初始化了 3 个对象
var c = new Boolean(true); // c 对象有个隐藏属性[[PrimitiveValue]]，值为布尔值 true
var d = new String('test');
var e = new Number(10);

// 然后把它们转化成基本值，不用new 操作符，直接调用Boolean 等对象
с = Boolean(c); // 现在c 的值是布尔值 true
d = String(d);
e = Number(e);
 
// 把这些基本值再转成对象
с = Object(c); // 现在c 又变成一个对象
d = Object(d);
e = Object(e);
```
此外，还有对象通过特殊内建构造器来创建：`Function` 是函数对象的构造器，`Array` 是数组的构造器， `RegExp` 是正则表达式的构造器，`Math` 是内置数学模块， `Date` 是日期的构造器等，它们都属于`Object` 类型，它们的特点由各自的内部属性来管理，之后我们会讨论到。

##### 1.2.4 字面量标记（litral notations）
对象、数组和正则表达式有简单标记法，分别叫做 [对象初始化](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)器，数组初始化器和正则表达式字面量：
```javascript
// 相当于 array = new Array(1, 2, 3);
// 或者 array = new Array();
// array[0] = 1;
// array[1] = 2;
// array[2] = 3;
var array = [1, 2, 3];
 
// 相当于
// var object = new Object();
// object.a = 1;
// object.b = 2;
// object.c = 3;
var object = {a: 1, b: 2, c: 3};
 
// 相当于 new RegExp("^\\d+$", "g")
var re = /^\d+$/g;
```

#### 1.2.5 关联数组（associative array）？
在一些文章或讨论中，人们会把 JavaScript 对象（尤其是通过对象初始化器`{}` 的声明方式创建的）叫做哈希表（`hash-tables`），或者简称哈希（来自Ruby 或者 Perl 语言）、关联数组（来自 PHP）、字典（来自 Python）等。

这些术语的运用是为了技术做更加准确的描述，实际上，从 `键值对` 存储数据的方式来说，它和`关联数组` 和 `哈希表` 都非常相似，并且在实现层面常常用的就是哈希表抽象数据类型。

然而，尽管一个术语是为了表达一种思考概念的方式，但就 ECMAScript 来说，上面哪些术语在技术上并不准确。我们知道 ECMAScript 只有一种对象类型，它的“子类型”从键值对存储数据的角度来说并没有分别。因此也就不用额外其他词（哈希什么的）来描述对象了，因为任何对象（不管其内部属性是什么），都能存放以下这些键值对：
```javascript
var a = {x: 10}; // 用对象初始化器方式创建对象a, 添加x,y,z 属性
a['y'] = 20;
a.z = 30;

var b = new Number(1); // 用 new 对 Number 对象进行构造调用，创建新对象b,添加x,y,z 属性
b.x = 10;
b.y = 20;
b.['z'] = 30;

var c = new Function(''); // 用 new 对 Function 对象进行构造调用，创建新对象c, 添加x,y,z 属性
c.x = 10;
c.y = 20;
c.['z'] = 30;
// 任何对象的子类都能这么添加属性
```

除此之外，ECMAScript 对象 因为 `委托(delegation)`的存在可以是非空的，说它是哈希不合适：
```javascript
Object.prototype.x = 10;
var a = {}; // 创建一个“空的”“哈希表”
console.log(a["x"]); // 10, 所以它是“非空”
console.log(a.toString); // 函数

a["y"] = 20; // 添加新的键值对到“哈希”
console.log(a["y"]); // 20
 
Object.prototype.y = 20; // 在原型中添加属性
 
delete a["y"]; // 移除a 的y 属性
console.log(a["y"]); // 20，但键值对还存在
```
注：ES5 标准中允许创建不带原型的对象，即对象的原型对象是 `null`，通过`Object.create(null)` 方法进行创建。从这个角度看，不带原型的对象就是个哈希表了：
```javascript
var aHashTable = Object.create(null);
console.log(aHashTable.toString); // undefined
```
ECMAScript 概念中的属性（“property”）在语义上并不能分解成 `键`、`数组索引`、或者固定称呼`方法/属性`，本质上它们是遵守原型链查询的读取算法的通用规则，而被叫做属性而已。

下面用的Ruby 的例子说明哈希在语义和结果上和 ECMAScript 对象的区别：
```ruby
a = {}
a.class # hash
a.length # 0
# 创建新的键值对
a['length'] = 10;
 
# 用 点`.` 来访问意味着访问它的`属性/方法`，而不是键
a.length # 1

# 用方括号`[]` 能访问哈希表的键
a['length'] # 10

# 我们可以给哈希类动态增加新的属性/方法，通过委托机制，它们在已存在的对象上是可访问的
class Hash
  def z
    100
  end
end
# 一个新属性已经就位
a.z # 100
a['z'] # nil 它不是`键`
```

#### 1.2.6 类型转换
用`valueOf` 方法可以把一个对象转换成基本值。之前我们提到，对于那些特定的构造器，不通过`new` 操作符，只进行普通函数调用，会把对象类型转换成基本值，实际上是隐性调用了 `valueOf` 方法：
```javascript
var a = new Number(1);
var primitiveA = Number(a); // 隐性调用了 "valueOf"
var alsoPrimitiveA = a.valueOf(); // 显式调用

console.log([
    typeof a, // "object"
    typeof primitiveA, // "number"
    typeof alsoPrimitiveA // "number"
]);
```
`valueOf` 方法让对象可以参与多种计算，如加法：
```javascript
var a = new Number(1);
var b = new Number(2);
console.log(a + b); // 3

// 甚至还可以这样
var c = {
  x: 10,
  y: 20,
  valueOf: function () {
    return this.x + this.y;
  }
};

var d = {
  x: 30,
  y: 40,
// 既然c 已经定义了valueOf 方法，那就借来用用吧：
  valueOf: c.valueOf
};

console.log(c + d); // 100
```

不同的对象类型，其默认（如果没有被改写的话）的`valueOf` 方法也不尽相同，有些对象会返回`this` 值，如 `Object.prototype.valueOf()`， 其他对象会返回计算过的值，如 `Date.prototype.valueOf()`， 会返回一个时期的时间：
```javascript
var a = {};
console.log(a.valueOf() === a); // true, "valueOf" 返回this 值
 
var d = new Date();
console.log(d.valueOf()); // 一串表示时间的数字
console.log(d.valueOf() === d.getTime()); // true
```

除此以外，还有一种表示对象的基础值的方式——对象的字符串表征，用到`toString` 方法：
```javascript
var a = {
  valueOf: function () {
    return 100;
  },
  toString: function () {
    return '__test';
  }
};

// 以下操作自动调用valueOf 方法
console.log(a + 10); // 110
 
// 假设对象没有valueOf 方法，会自动调用toString 方法
delete a.valueOf;
console.log(a + 10); // "_test10"
```
注：`Object.prototype` 中的 `toString` 方法有特殊用法：它会返回内部的 [[Class]] 属性，后面我们会讨论。

和转成基本基本值方法相对的，也有方法把基本值转化成对象类型。其中之一是用普通函数调用来调用`Object` 构造器（有些类型，也可以用 `new` 操作符来调用）：
```javascript
var n = Object(1); // 转成了一个对象，属于 Number 包装类型
var s = Object('test'); // 转成了一个对象，属于 String 包装类型

// 有些类型，也可以用 `new` 操作符来调用，如布尔值
var b = new Object(true); // 转成了一个对象，属于 Boolean 包装类型

// 如果没有参数的话，new Object 操作会创建一个新对象
var o = new Object(); // 一个新对象，属于 Object 类型
 
// 如果Object 函数传入的参数已经是个对象，则直接返回它。
var a = [];
console.log(a === new Object(a)); // true
console.log(a === Object(a)); // true
```

对于用不用 `new` 来调用内建构造器造成的结果是否一样，没有通用规则，取决于具体构造器。如`Array` 和 `Function` 构造器无论是否用 `new` 调用，结果都一样：
```javascript
var a = Array(1, 2, 3); // a 是 Array 对象
var b = new Array(1, 2, 3); //  b 是 Array 对象
var c = [1, 2, 3]; // c 是 Array 对象
 
var d = Function(''); // d 是 Function 对象
var e = new Function(''); // e 是 Function 对象
```

当使用操作符时，也会进行显性或隐性的类型转换：
```javascript
var a = 1;
var b = 2;

// 隐性类型转换
var c = a + b; // 3, 数字
var d = a + b + '5' // "35", 转成了字符串

// 显性类型转换
var e = '10'; // "10", 是个字符串
var f = +e; // 10, 转成了数字
var g = parseInt(e, 10); // 10, 转成了数字
```

#### 1.2.7 属性的特性（property attributes）
`property` 和`attribute` 在表达`属性`或者类似含义时没有区别，这两个词放在一起，总不能叫属性的属性，所以为做区分`property` 叫做属性，`attribute` 叫做属性的`特性`，可以联系一个对象来理解，一个对象是由不同`property` 构成，其中每个 `property` 都有一些诸如`能否改写`、`能否删除`等特性。

每个属性都有一些特性：
- {`ReadOnly`}，任何尝试改写属性值的行为都会被忽略，但是，`ReadOnly` 属性可以被宿主环境的行为更改，所以`ReadOnly` 并不意味是是个不变的值；
- {`DontEnum`}，这个属性不会被`for..in` 枚举出来；
- {`DontDelete`}，任何尝试删除性的行为会被忽略；
- {`Internal`}，这个属性是内部的，它没有名字供外部访问，只在`实现`层面使用，这类属性在ECMAScript 程序中无法访问。

注：在ES5 标准中，{`ReadOnly`}，{`DontEnum`} 和{`DontDelete`} 被相应改成了`[[Writable]]`, `[[Enumerable]]` 和 `[[Configurable]]`，可以通过 `Object.defineProperty` 及类似方法来人为管理：
```javascript
var foo = {};
Object.defineProperty(foo, "x", {
    value: 10,
    writable: true, // 即 {ReadOnly} = false
    enumerable: false, // 即 {DontEnum} = true
    configurable: true // 即 {DontDelete} = false
});
 
console.log(foo.x); // 10
 
// 通过属性描述符来访问这些特性
var desc = Object.getOwnPropertyDescriptor(foo, "x");

console.log(desc.enumerable); // false
console.log(desc.writable); // true
```

#### 1.2.8 内部属性和内部方法
对象也有一些内部属性，它们是 ES 实现的一部分，不能被 ECMAScript 程序直接访问（但后面我们会看到，有些实现允许访问某些内部属性），这些内部属性用双方括号表示，`[[]]`。
每个对象都要实现这些内部属性和方法：
- `[[Prototype]]`，用于访问对象的原型；
- `[[Class]]`，用字符串表示的对象种类（如 `Object`,`Array`,`Function`等），用来区别不同的对象；
- `[[Get]]`，用于获取属性值的方法；
- `[[Put]]`，用于设定属性值的方法；
- `[[CanPut]]`，用于检查是否可以改写属性；
- `[[HasProperty]]`，用于检查对象是否已经拥有某个属性；
- `[[Delete]]`，用于移除对象的属性；
- `[[DefaultValue]]`，返回一个和对象关联的基本值（会在内部调用`valueOf` 方法来获取这个基本值，对于有些对象，可能会抛出`TypeError` 错误）。ECMAScript 程序中可以用 `Object.prototype.toString()` 方法非直接地获取`[[Class]]` 属性的值，该方法返回如下字符串 `"[object" + [[Class]] + ]"`， 如：
```javascript
var getClass = Object.prototype.toString;
getClass.call({}); // [object Object]
getClass.call([]); // [object Array]
getClass.call(new Number(1)); // [object Number]
```
我们常用这个方法来检查是个什么种类的对象。但该方法对一些宿主对象没那么准确，如：想要获取`document.childNodes.item(...)` 方法的 `[[Class]]` 属性时，在老版本的 IE 浏览器会返回`“String”`，在其他实现中，返回`"Function"`：
```javascript
// 老版本 IE - "String", 其他浏览器 - "Function"
console.log(getClass.call(document.childNodes.item));
```

### 2. 构造器
在 ECMAScript 中，对象通过所谓的`构造器`进行创建：
>构造器是一个函数，用来创建并初始化一个新对象。

创建对象实际上是为它分配内存，由构造器中的 `[[Construct]]`内部方法负责，这个内部方法是特定的，所有构造器函数都用它为新对象分配内存。

初始化对象通过调用新建对象上下文中的函数来实现，由构造器函数中的内部`[[Call]]` 方法负责。

注意，用户代码只能访问初始化阶段发生的事。尽管如此，我们也可以在初始化阶段返回一个特殊的对象，来覆盖第一阶段创建的`this` 对象：
```javascript
function A() {
	// 为新对象设定x 属性
  this.x = 10;
	// 但最终显式返回一个不同的对象
  return [1, 2, 3];
}

var a = new A();
console.log(a.x, a); // undefined, [1, 2, 3]
```

函数是一个本地对象，有内部属性 `[[Construct]` 、 `[[Call]]` 以及显式属性 `prototype`——为经它创建的对象设置原型的引用。`[[Call]]` 的存在与否是进行对象区别的主要因素，有内部属性 `[[Call]]` 的对象就叫做函数。`typeof`操作符用在这些对象上会返回`"function"`值。

用`new` 操作符应用到构造器函数时，会调用其内部 `[[Construct]` 方法，如果没有参数，那`()` 也可以省略。
```javascript
function A(x) { // 构造器 А
  this.x = x || 10;
}
// 没有参数可以省略（）
var a = new A; // 相当于 new A();
console.log(a.x); // 10

// 显示传入x 参数值
var b = new A(20);
console.log(b.x); // 20
```
在初始化对象阶段，构造器中的 `this` 值已经指向了新建的对象。
接着我们讨论创建对象时用到的算法。
#### 2.1 对象构造的算法
内部方法 `[[Construct]]` 的行为可以用以下**伪代码**描述：
```javascript
F.[[Construct]](initialParameters):
O = new NativeObject();
// [[Class]] 属性被设置为 "Object"
O.[[Class]] = "Object";

// 得到F 构造器函数此时的prototype 对象
var __objectPrototype = F.prototype;

// 如果__objectPrototype 是对象，把它赋值给新对象的内部属性[[Prototype]]
O.[[Prototype]] = __objectPrototype;
// 否则，把Object.prototype 赋值给新对象的内部属性[[Prototype]]
O.[[Prototype]] = Object.prototype;

// 通过调用F.[[Call]] 初始化新创建的对象，把[[this]]值设定为新建的对象
// 参数和传入F 的初始参数一样
R = F.[[Call]](initialParameters); this === O;
// 调用 [[Call]] 后返回R 
// 这在 JS 视角里就像:
// R = F.apply(O, initialParameters);

// 如果R 是对象，返回R
return R
// 否则返回 O
return O
```
两点注意一下：
1. 从构造器的 `prototype` 属性获取的原型对象，是创建`当时`的样子，这意味着即使有两个对象先后通过同一个构造器创建，它们的原型也可能不一样。
2. 上面提到过，如果在对象初始化阶段，`[[Call]]` 返回了一个对象，那么整个`new` 表达式就会返回这个对象：
```javascript
function A() {}
A.prototype.x = 10;

var a = new A();
console.log(a.x); // 10，从原型对象中委托找到了 x 的值

// 把 A 函数的prototype 属性设为一个新对象
// 后面会讨论为什么要显式地设定.constructor 属性
A.prototype = {
  constructor: A,
  y: 100
};

var b = new A();
// b 对象有新原型
console.log(b.x); // undefined
console.log(b.y); // 100，从新的原型对象中委托找到了 y 的值
 
// 然而 a 对象的原型还是原来的那个
console.log(a.x); // 10

function B() {
  this.x = 10;
  return new Array();
}

// 如果 B 构造器没有任何返回，或者返回 this ，那么 this 所指向的对象就会发挥作用，但在上面这个例子中，B 构造器显式返回一个数组
var b = new B();
console.log(b.x); // undefined
console.log(Object.prototype.toString.call(b)); // [object Array]
```

接下来我们深入讨论原型。
### 3. 原型
每个对象都有原型（一些系统级对象可能是例外），原型的访问借助于一个内置隐藏、不能直接访问的`[[Prototype]]` 属性，一个原型要么是一个对象，要么是`null`。

#### 3.1 属性构造器
在上面的例子中，有两点很重要：
一是函数的`prototype` 属性中有`constructor` 属性，在函数对象创建的算法演示中，在函数创建阶段，`constructor` 属性被设置到函数的`prototype` 属性上，这是属性的值被回指（circular reference）向函数自身：
```javascript

```

#### 3.2 外显原型和隐藏的` [[Prototype]]` 属性
#### 3.3 非标准定义的` __proto__` 属性
#### 3.4 对象独立于它的构造器
#### 3.5 `instanceof` 操作符的特性
#### 3.6 作为存储方法共享属性的原型

### 4. 读写属性
#### 4.1 `[[Get]]`方法
#### 4.2 `[[Put]]`方法
#### 4.3 属性获取符

### 5. 继承
#### 5.1 原型链

## 3. 结论

## 4. 其他文献











原文链接
[ECMA-262-3 in detail. Chapter 7.2. OOP: ECMAScript implementation.](http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/#type-conversion)